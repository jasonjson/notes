## Asyncio

* The fundamental way that most asynchronous applications work is via an **event loop** that runs in the background. When something needs to run, it is registered to the event loop, which becomes a **task**.
* Tasks are primarily registered to the loop using `call_soon`, which operates as a FIFO queue. It's also possible to register a task called until later using `call_later` method.
* Most `asyncio` mehtods only take function objects (or other callables). The `functools.partial` method itself takes the arguments and keyword arguments that must be passed to the underlying function.
* A **coroutine** is a special kind of function designed to run within an event loop. You can make a function into a coroutine by decorating it with `@asyncio.coroutine`. Howver, the function created is a special generator consumeed by the event loop and you can no longer call it the regular way.
* You can add a callback to any `Future` object by using the object's `add_done_callback` method. Callbacks are expected to take a single argument, which is the `Future` object itself.
* It is possible to send other arguments to a callback through the use of `functools.partial`. In practice, the `Future` is appended to the end of the positional arguments list before the callback is called.
* The `asyncio` module provides a convenient way to aggregate tasks for two reasons: the first is to take some sort of action once any task in a set of tasks has completed, the second is to take some sort of action once all tasks in the set have completed.
* In the case of a task created with `asyncio.gather`, the result is always a list, which contains the results of the individual task that were gathered. The order of the list of results is guaranteed to be the same order in which the tasks were gathered (but the tasks are not guaranteed to be run in that order).
* The `asyncio.wait` coroutine takes a sequence of coroutines or tasks and returns once they are done. Additionaly, `wait` accepts a parameter to return when **any** of its tasks complete. The `wait` method always returns a two-tuple, with the first element being the `Future` objects that have completed, and the second element being those are still pending.
* It is possible to pass the `timeout` keyword argument to have the `asyncio.wait` coroutine return when a specific amount of time has passed, regardless of whether all of the tasks have completed.
* A **queue** is a collection of tasks to be processed by a task runner. Two methods `put_nowait` and `get_nowait` are designed to perform addition or removeal of the item to or from the queue immediately. Another method `get` will patiently wait for an item to be added to the queue, and then retrieve it from the queue and return it immediately. It's possible to give a **queue** object a maximum size, by setting the `maxsize` keyword argument.
